---
title: 分布式事务基本原理
categories: ['分布式']
tags: ['分布式', '事务']
date: 2019-06-21 11:30
---

# 分布式事务基本原理

> 📦 本文已归档到：「[blog](https://github.com/dunwu/blog)」
>
> **分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。**

<!-- TOC depthFrom:2 depthTo:3 -->

- [一、分布式事务简介](#一分布式事务简介)
  - [事务](#事务)
  - [CAP 和 BASE](#cap-和-base)
  - [分布式事务](#分布式事务)
- [二、两阶段提交](#二两阶段提交)
  - [1.1. 运行过程](#11-运行过程)
  - [1.2. 问题](#12-问题)
  - [1.3. 优缺点](#13-优缺点)
- [三、补偿事务](#三补偿事务)
- [四、本地消息表](#四本地消息表)
  - [3.1. 优缺点](#31-优缺点)
- [五、MQ 事务](#五mq-事务)
- [六、SAGA](#六saga)
- [参考资料](#参考资料)

<!-- /TOC -->

## 一、分布式事务简介

> 💡 学习分布式事务之前，请先理解[事务](https://dunwu.github.io/db-tutorial/#/sql/sql-interview?id=%e4%ba%8c%e3%80%81%e4%ba%8b%e5%8a%a1)和[分布式基础理论](cap-and-base.md)。

### 事务

事务简单来说：**一个 Session 中所进行所有的操作，要么同时成功，要么同时失败**。具体来说，事务指的是满足 ACID 特性的一组操作，可以通过 `Commit` 提交一个事务，也可以使用 `Rollback` 进行回滚。

> 💡 更详细的内容可以参考：[事务](https://dunwu.github.io/db-tutorial/#/sql/sql-interview?id=%e4%ba%8c%e3%80%81%e4%ba%8b%e5%8a%a1)

### CAP 和 BASE

CAP 定理又称为 CAP 原则，指的是：**在一个分布式系统中， `一致性（C：Consistency）`、`可用性（A：Availability）` 和 `分区容忍性（P：Partition Tolerance）`，最多只能同时满足其中两项**。

BASE 是 **`基本可用（Basically Available）`**、**`软状态（Soft State）`** 和 **`最终一致性（Eventually Consistent）`** 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

> 💡 更详细的内容可以参考：[分布式基础理论](cap-and-base.md)

### 分布式事务

**分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。**

分布式事务的实现主要有以下 5 种方案：

- XA 方案
- TCC 方案
- 本地消息表
- 可靠消息最终一致性方案
- 最大努力通知方案

## 二、两阶段提交

> 两阶段提交（Two-phase Commit，2PC）通过引入协调者（Coordinator）来调度参与者的行为，并最终决定这些参与者是否要真正执行事务。
>
> 参考实现：https://github.com/changmingxie/tcc-transaction

### 1.1. 运行过程

#### 1.1.1. 准备阶段

协调者询问参与者事务是否执行成功，参与者发回事务执行结果。

<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-01.jpg!zp" />
</div>

#### 1.1.2. 提交阶段

如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。

<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务两阶段提交-02.jpg!zp" />
</div>

需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。

### 1.2. 问题

- **同步阻塞** - 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。
- **单点问题** - 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响，特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。
- **数据不一致** - 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
- **太过保守** - 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。

### 1.3. 优缺点

- 优点：尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能 100%保证强一致）
- 缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。

## 三、补偿事务

补偿事务（TCC），全称是：`Try`、`Confirm`、`Cancel`。

其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

- **Try 阶段**：这个阶段说的是对各个服务的资源做检测以及对资源进行**锁定或者预留**。
- **Confirm 阶段**：这个阶段说的是在各个服务中**执行实际的操作**。
- **Cancel 阶段**：如果任何一个服务的业务方法执行出错，那么这里就需要**进行补偿**，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）

举个例子，假设 Bob 要向 Smith 转账，思路大概是：

1. 首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
2. 在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
3. 如果第 2 步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。

优缺点：

- 优点：跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些。
- 缺点：缺点还是比较明显的，在 2,3 步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。

这种方案几乎很少人使用，因为**事务回滚**实际上是**严重依赖于自己写代码来回滚和补偿**了，会造成补偿代码巨大。

但是，也有特殊的使用场景：一般来说跟**钱**相关的，跟钱打交道的，**支付**、**交易**相关的场景，会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。

而且最好是你的各个业务执行的时间都比较短。

但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。

## 四、本地消息表

> 本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性。
>
> 1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
> 2. 之后将本地消息表中的消息转发到 Kafka 等消息队列（MQ）中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
> 3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。

<div align="center">
<img src="http://dunwu.test.upcdn.net/cs/design/architecture/分布式事务本地消息.jpg!zp" />
</div>

这种方案遵循 BASE 理论，采用的是最终一致性。

本地消息表利用了本地事务来实现分布式事务，并且使用了消息队列来保证最终一致性。

### 3.1. 优缺点

- 优点：一种非常经典的实现，避免了分布式事务，实现了最终一致性。
- 缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。

## 五、MQ 事务

有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交。但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。

以阿里的 RocketMQ 中间件为例，其思路大致为：

1. Prepared 消息，会拿到消息的地址。
2. 执行本地事务。
3. 通过第一阶段拿到的地址去访问消息，并修改状态。

也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。

## 六、SAGA

Saga 事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的 H.Garcia-Molina 等人提出，它描述的是另外一种在没有两阶段提交的的情况下解决分布式系统中复杂的业务事务问题。你可以在[这里](https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf)看到 Sagas 相关论文。

我们这里说的是一种基于 Sagas 机制的工作流事务模型，这个模型的相关理论目前来说还是比较新的，以至于百度上几乎没有什么相关资料。

该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么 Sagas 工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。

比如我们一次关于购买旅游套餐业务操作涉及到三个操作，他们分别是预定车辆，预定宾馆，预定机票，他们分别属于三个不同的远程接口。可能从我们程序的角度来说他们不属于一个事务，但是从业务角度来说是属于同一个事务的。

![img](https://images2017.cnblogs.com/blog/250417/201710/250417-20171016220040115-805407978.png)

他们的执行顺序如上图所示，所以当发生失败时，会依次进行取消的补偿操作。

## 参考资料

- [聊聊分布式事务，再说说解决方案](https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html)
