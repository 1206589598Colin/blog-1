---
title: 深入理解一致性算法 Raft
categories: ['设计', '系统原理']
tags: ['设计', '系统原理', '分布式']
date: 2020-02-01 00:40
---

# 深入理解一致性算法 Raft

<!-- TOC depthFrom:2 depthTo:3 -->

- [一、Raft 简介](#一raft-简介)
  - [分布式一致性](#分布式一致性)
  - [复制状态机](#复制状态机)
  - [RAFT 应用](#raft-应用)
- [二、Raft 基础](#二raft-基础)
  - [角色](#角色)
  - [任期](#任期)
- [三、Leader 选举](#三leader-选举)
  - [选举规则](#选举规则)
  - [单 Candidate 选举](#单-candidate-选举)
  - [多 Candidate 选举](#多-candidate-选举)
- [四、日志复制](#四日志复制)
- [五、安全性](#五安全性)
- [参考资料](#参考资料)

<!-- /TOC -->

## 一、Raft 简介

[Raft](https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf) 是一种为了管理复制日志的分布式一致性算法。

Raft 算法出现之前，Paxos 一直是分布式一致性协议的标准。Paxos **难以理解，更难以实现**。Raft 的设计目标是简化 Paxos，使得算法**既容易理解，也容易实现**。

Paxos 和 Raft 都是分布式一致性算法，这个过程如同选举领袖（Leader），参选者（Candidate）需要说服大多数投票者（Follower）投票给他，一旦选举出领袖，就由领袖发号施令。Paxos 和 Raft 的区别在于选举的具体过程不同。

Raft 可以解决分布式 CAP 理论中的 CP，即 **`一致性（C：Consistency）`** 和 **`分区容忍性（P：Partition Tolerance）`**，并不能解决 **`可用性（A：Availability）`** 的问题。

### 分布式一致性

分布式一致性 (distributed consensus) 是分布式系统中最基本的问题，用来保证一个分布式系统的可靠性以及容错能力。简单来说，**_分布式一致性是指多个服务器的保持状态一致_**。

在分布式系统中，可能出现各种意外（断电、网络拥塞、CPU/内存耗尽等等），使得服务器宕机或不可用，最终导致无法和其他服务器保持状态一致。为了应对这种情况，就需要有一种一致性协议来进行容错，使得分布式系统中即使有部分服务器宕机，整体依然可以对外提供服务。

以容错方式达成一致，自然不能要求所有服务器都达成一致状态，只要**超过半数以上**的服务器达成一致就可以了。这意味着：假设有 N 台服务器， 大于等于 $\frac{N}{2}+1$ 台服务器达成一致就可以了。

### 复制状态机

复制状态机是指一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。 一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。

![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20200131233906.png)

复制状态机通常都是基于复制日志实现的，如上图。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。

保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。

实际系统中使用的一致性算法通常含有以下特性：

- **安全性保证**（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。
- **可用性**：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。
- **不依赖时序来保证一致性**：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。
- 通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。

### RAFT 应用

RAFT 可以做什么？

通过 RAFT 提供的复制状态机，可以解决分布式系统的复制、修复、节点管理等问题。Raft 极大的简化当前分布式系统的设计与实现，让开发者只关注于业务逻辑，将其抽象实现成对应的状态机即可。基于这套框架，可以构建很多分布式应用：

- 分布式锁服务，比如 Zookeeper
- 分布式存储系统，比如分布式消息队列、分布式块系统、分布式文件系统、分布式表格系统等
- 高可靠元信息管理，比如各类 Master 模块的 HA

## 二、Raft 基础

Raft 将一致性问题分解成了三个子问题：

- **选举 Leader**
- **日志复制**
- **安全性**

### 角色

在 Raft 中，任何时刻，每个服务器都处于这三个角色之一 ：

- **`Leader`** - 通常一个系统中是**一主（Leader）多从（Follower）**。Leader **负责处理所有的客户端请求**。
- **`Follower`** - Follower 都是被动的，**不会发送任何请求**，只是简单的 **响应来自 Leader 或者 Candidate 的请求**。
- **`Candidate`** - 参选者，选举新 Leader 时使用。

![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20200131215742.png)

Follower 只响应来自其他服务器的请求。如果 Follower 超过一定时限接收不到消息，就会转变成 Candidate，并发起一次选举。获得集群中半数以上选票的 Candidate 将成为 Leader。在一个任期（Term）内，Leader 始终保持不变，直到宕机了。

### 任期

![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20200131220742.png)

时间被划分成一个个的任期，**每个任期开始都是一次选举**。**Raft 保证了在一个给定的任期内，最多只有一个领导者**。

- 如果选举成功，Leader 会管理整个集群直到任期结束。
- 如果选举失败，那么这个任期就会因为没有 Leader 而结束。

**任期之间的切换可以在不同的时间、不同的服务器上观察到**。

- 服务器节点可能多次观察到任期的转换
- 服务器节点也可能观察不到任何一次选举或者整个任期全程。

**任期在 Raft 算法中充当逻辑时钟的作用**。**每个服务器节点都会存储一个当前任期号，这一编号在整个时期内单调的增长**。服务器节点可以通过任期查明一些过期的信息，比如过期的 Leader。当服务器之间通信的时候会交换当前任期号。

- 如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。
- 如果一个 Candidate 或者 Leader 发现自己的任期号过期了，那么他会立即恢复成跟随者状态。
- 如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。

## 三、Leader 选举

### 选举规则

**Raft 使用一种心跳机制来触发 Leader 选举**。

**Leader 需要周期性的向所有 Follower 发送心跳消息**，以此维持自己的权威并且阻止新的 Leader 的产生。

每个 Follower 都设置了一个**随机的竞选超时时间**，一般为 150ms\~300ms，如果在竞选超时时间内没有收到 Leader 的心跳消息，就会认为当前任期没有可用的 Leader，并发起选举以选出新的 Leader。开始一次选举过程，Follower 先要增加自己的当前任期号，并**转换为 Candidate**。

Candidate 会并行的**向集群中的所有服务器节点发送投票请求**，它会保持当前状态直到以下三件事情之一发生：

- **他自己赢得了这次的选举** - 当一个 Candidate 从整个集群半数以上的服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为 Leader。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则。要求大多数选票的规则确保了最多只会有一个 Candidate 赢得此次选举。
- **其他的服务器成为 Leader** - 在等待投票的时候，Candidate 可能会收到其他自称是 Leader 的服务器的消息。
  - 如果这个 Leader 的任期号不小于 Candidate 当前的任期号，那么 Candidate 会承认 Leader 合法并回到 Follower 状态。
  - 如果此次 RPC 中的任期号比自己小，那么 Candidate 就会拒绝这个消息并继续保持 Candidate 状态。
- **超过一定时限任然没有任何服务器成为 Leader** - 如果有多个 Follower 同时成为 Candidate，那么选票可能会被瓜分以至于没有 Candidate 可以赢得半数以上的投票。当这种情况发生的时候，每一个 Candidate 都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。
  - Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把选举都分散开，以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个 Candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。

---

理解了上面的选举规则后，我们通过动图来加深认识。

### 单 Candidate 选举

下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的选举超时时间之后，没收到 Leader 发来的心跳消息。因此，将任期（Term）由 0 增加为 1，转换为 Candidate，进入选举状态。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-01.gif)

此时，A 向所有其他节点发送投票请求。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-02.gif)

其它节点会对投票请求进行回复，如果超过半数以上的节点投票了，那么该 Candidate 就会立即变成任期（Term） 1 的 Leader。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-03.gif)

Leader 会周期性地发送心跳消息给所有 Follower，Follower 接收到心跳包，会重新开始计时。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-candidate-04.gif)

### 多 Candidate 选举

如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Candidate B 和 Candidate D 都发起任期 4 的选举，且都获得两票，因此需要重新开始投票。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-multi-candidate-01.gif)

当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-multi-candidate-02.gif)

## 四、日志复制

一旦一个 Leader 被选举出来，他就开始为客户端提供服务。客户端的每一个请求都包含一条被复制状态机执行的指令。Leader 把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全的复制（下面会介绍），Leader 会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果 Follower 崩溃或者运行缓慢，再或者网络丢包，Leader 会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的 Follower 都最终存储了所有的日志条目。

图 6

图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候，就认为是可以提交了。

日志以图 6 展示的方式组织。每一个日志条目存储一条状态机指令和从 Leader 收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图 3 中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。

Leader 来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为已提交。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在 Leader 将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。同时，Leader 的日志中之前的所有日志条目也都会被提交，包括由其他 Leader 创建的条目。5.4 节会讨论某些当在 Leader 改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。Leader 跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道 Leader 的提交位置。一旦 Follower 知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。

我们设计了 Raft 的日志机制来维护一个不同服务器的日志之间的高层次的一致性。这么做不仅简化了系统的行为也使得更加可预计，同时他也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些同时也组成了图 3 中的日志匹配特性：

如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。
如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。
第一个特性来自这样的一个事实，Leader 最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，Leader 会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。如果 Follower 在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查保护了日志匹配特性当日志扩展的时候。因此，每当附加日志 RPC 返回成功时，Leader 就知道 Follower 的日志一定是和自己相同的了。

在正常的操作中，Leader 和 Follower 的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，Leader 崩溃的情况会使得日志处于不一致的状态（老的 Leader 可能还没有完全复制所有的日志条目）。这种不一致问题会在 Leader 和 Follower 的一系列崩溃下加剧。图 7 展示了 Follower 的日志可能和新的 Leader 不同的方式。Follower 可能会丢失一些在新的 Leader 中有的日志条目，他也可能拥有一些 Leader 没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。

图 7

图 7：当一个 Leader 成功当选时，Follower 可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。Follower 可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是 Leader，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为 Leader，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。

在 Raft 算法中，Leader 处理不一致是通过强制 Follower 直接复制自己的日志来解决了。这意味着在 Follower 中的冲突的日志条目会被 Leader 的日志覆盖。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。

要使得 Follower 的日志进入和自己一致的状态，Leader 必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给 Follower。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。Leader 针对每一个 Follower 维护了一个 nextIndex，这表示下一个需要发送给 Follower 的日志条目的索引地址。当一个 Leader 刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的 index 加 1（图 7 中的 11）。如果一个 Follower 的日志和 Leader 不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被 Follower 拒绝之后，Leader 就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得 Leader 和 Follower 的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把 Follower 冲突的日志条目全部删除并且加上 Leader 的日志。一旦附加日志 RPC 成功，那么 Follower 的日志就会和 Leader 保持一致，并且在接下来的任期里一直继续保持。

如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，Follower 可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息，Leader 可以减小 nextIndex 越过所有那个任期冲突的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。

通过这种机制，Leader 在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能自动的在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。Leader 从来不会覆盖或者删除自己的日志（图 3 的 Leader 只附加特性）。

日志复制机制展示出了第 2 节中形容的一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；并且单个的缓慢的 Follower 不会影响整体的性能。

- 来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-01.gif)

- Leader 会把修改复制到所有 Follower。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-02.gif)

- Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-03.gif)

- 此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。

![img](http://dunwu.test.upcdn.net/cs/design/architecture/raft-sync-log-04.gif)

## 五、安全性

## 参考资料

- [Raft 一致性算法论文原文](https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf)
- [Raft 一致性算法论文译文](https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md)
- [分布式系统的 Raft 算法](https://www.jdon.com/artichect/raft.html)
- [sofa-jraft](https://github.com/sofastack/sofa-jraft) - 蚂蚁金服的 Raft 算法实现库（Java 版）
